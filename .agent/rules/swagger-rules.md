---
trigger: always_on
---

follow this for the swagger decorators
To maintain a clean and scalable codebase, all API documentation must be decoupled from controller logic by using a dedicated swagger directory. Every resource requires a corresponding [resource].swagger.ts file named in kebab-case (e.g., user-profiles.swagger.ts) located in src/swagger/, which must be exported through a central index.ts file. These files serve as the exclusive location for all Swagger-related metadata, using the applyDecorators utility to group decorators such as @ApiOperation, @ApiResponse, @ApiParam, and @ApiQuery into reusable constants. Controllers must remain lean, using only the @ApiTags decorator at the class level and referencing the external swagger constants directly on individual methods.

The development workflow dictates that swagger documentation must be created or updated in tandem with any controller changes. Before an endpoint is added, modified, or deleted, its corresponding swagger decorator must be adjusted to reflect the current state of the API, including accurate summaries, detailed descriptions, and all possible HTTP response codes. To ensure consistency, swagger decorator names should match their respective controller method names using camelCase (e.g., findAll, rateBranch). High-quality documentation is mandatory; always specify DTO types for request bodies, indicate array responses where applicable, and include @ApiBearerAuth for protected routes. Under no circumstances should swagger decorators be placed directly inside controller files, as this violates the project's separation of concerns and maintainability standards.
